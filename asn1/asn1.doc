
=== Structures ===

ASN1
  Represents a single ASN.1 value. See the section below about ASN.1 data
  formats for an explanation of what the ASN.1 formats mean.

  .data = A pointer to the beginning of the raw primitive or constructed
  data, excluding the bytes for the class, type, and length.

  .length = The length of the data in bytes.

  .type = The type number. If the class is ASN1_UNIVERSAL (0) then this is
  one of the constants listed near the top of the asn1.h file.

  .class = The class, which can be ASN1_UNIVERSAL (0), ASN1_APPLICATION
  (1), ASN1_CONTEXT_SPECIFIC (2), or ASN1_PRIVATE (3).

  .constructed = Zero if primitive or one if constructed.

ASN1_DateTime
  Represents a general date/time, including time zone.

  .zone = The time zone, in minutes from UTC; positive numbers are east and
  negative numbers are west.

  .year = The AD year number.

  .month = The month number from 1 to 12.

  .day = The day number from 1 to 31.

  .hours = The number of hours from 0 to 23.

  .minutes = The number of minutes past the hour, from 0 to 59.

  .seconds = The number of seconds past the minute, normally from 0 to 59,
  but may be 60 in the case of leap seconds.

ASN1_Encoder
  This is an opaque type, which is used during encoding.


=== Return values ===

Except as otherwise specified, all functions return an error code, where
zero means OK and nonzero means error.


=== General functions ===

asn1_date_to_time(const ASN1_DateTime*in,time_t*out,uint32_t*nano)
  Convert a ASN1_DateTime structure to UNIX time.

  in = The structure with the date/time to be converted.

  out = Where the output time is written to. In the case of leap seconds,
  the timestamp is the same as that for the last second of the same minute.

  nano = It may be null. If it is not null, writes the number of
  nanoseconds past the UNIX time. This is normally less than one billion,
  but can exceed one billion in the case of leap seconds.

asn1_distinguished_parse(const uint8_t*,size_t,ASN1*,size_t*)
  Same as asn1_parse but does not allow indefinite encoding, and requires
  that the type and length are encoded in the minimum number of bytes.

asn1_from_c_string(uint8_t class,uint32_t type,const char*data,ASN1*out)
  Converts a null-terminated C string into a ASN1 structure (which will
  contain a pointer to the string). The type cannot be automatic; it must
  be specified explicitly. Passing a null pointer is an error.

asn1_parse(const uint8_t*data,size_t length,ASN1*out,size_t*next)
  Parses a ASN.1 BER value from memory. This does not decode the value.

  data = The pointer to the data.

  length = The maximum length of the data. It will not try to read past
  this length. If this length is not big enough to parse a single value,
  then it returns ASN1_TOO_SHORT.

  out = The ASN1 structure to write the parsed value into.

  next = It may be null. If it is not null, then the total length that has
  been read is added to the variable that it points to, so that you may
  know where to start reading from next.

void asn1_write_length(uint64_t length,FILE*stream)
  Writes a length header of a ASN.1 item.

  length = The length of the data within the item (not including the header
  itself). This does not write the data; only the length header is written.

  stream = File to be written to.

void asn1_write_type(uint8_t constructed,uint8_t class,uint32_t type,FILE*stream)
  Writes a class/type header of a ASN.1 item.

  constructed = Set to nonzero for constructed or zero for primitive.

  class = Class of value.

  type = Type of value. The class and type should not both be zero.

  stream = File to be written to.


=== Decoding functions ===

Most of these functions have the first two arguments being "asn" and
"type", where "asn" is the value to decode, and "type" specifies the ASN.1
universal type of the value. If the type is ASN1_AUTO then it will decide
the type automatically from the ASN1 structure; in this case, the class
must be ASN1_UNIVERSAL or ASN1_CONTEXT_SPECIFIC (in which case it assumes
it is an explicit type). If the type passed to the function is not
ASN1_AUTO then it assumes that it is an implicit type and uses the type
you specified instead.

asn1_decode_date(const ASN1*asn,uint32_t type,ASN1_DateTime*out)
  Decodes one of the ASN.1 date/time types. The time zone in the output is
  left unchanged if the ASN.1 value does not specify the time zone, but if
  it does specify the time zone then it will use the time zone in the
  ASN.1 value instead. It will also keep any existing values in the output
  structure for the ASN.1 types that only specify date or only time of day,
  in which case the time of day or the date is kept as it is.

asn1_decode_int8(const ASN1*asn,uint32_t type,int8_t*out)
  Decodes a signed 8-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 8-bit integer.

asn1_decode_int16(const ASN1*asn,uint32_t type,int16_t*out)
  Decodes a signed 16-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 16-bit integer.

asn1_decode_int32(const ASN1*asn,uint32_t type,int32_t*out)
  Decodes a signed 32-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 32-bit integer.

asn1_decode_int64(const ASN1*asn,uint32_t type,int64_t*out)
  Decodes a signed 64-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 64-bit integer.

asn1_decode_number(const ASN1*asn,uint32_t type,???*out)
  A macro that calls one of the other numeric decoding functions according
  to the type of the "out" argument.

asn1_decode_time(const ASN1*asn,uint32_t type,int16_t zone,time_t*out,uint32_t*nano)
  Combines asn1_decode_date and asn1_date_to_time. The defaults for any
  fields other than the time zone will be zero.

  zone = The default time zone, in minutes (specify 0 for UTC). It is
  ignored if the ASN.1 value explicitly specifies the time zone.

asn1_decode_uint8(const ASN1*asn,uint32_t type,uint8_t*out)
  Decodes a unsigned 8-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 8-bit integer.

asn1_decode_uint16(const ASN1*asn,uint32_t type,uint16_t*out)
  Decodes a unsigned 16-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 16-bit integer.

asn1_decode_uint32(const ASN1*asn,uint32_t type,uint32_t*out)
  Decodes a unsigned 32-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 32-bit integer.

asn1_decode_uint64(const ASN1*asn,uint32_t type,uint64_t*out)
  Decodes a unsigned 64-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 64-bit integer.

asn1_get_bit(const ASN1*asn,uint32_t type,uint64_t which,int*out)
  Reads a single bit from a value.

  which = Which bit to read. How this number is interpreted depends on
  the type, as follows:

  ASN1_BIT_STRING: The high bit of the first byte (although this is not
  the first byte of the encoded value) is bit 0.

  ASN1_OCTET_STRING: The low bit of the first byte is bit 0.

  ASN1_INTEGER: The low bit of the last byte is bit 0. If the bit
  position number is out of range, then it uses the high bit of the
  first byte (the sign bit), instead of leaving it unchanged.

  ASN1_BOOLEAN: The bit position number is ignored.

  out = Where to store the bit that has been read. If the requested bit
  number is out of range then it remains unchanged (therefore allowing
  the use of default values, which is usually zero).

asn1_print_decimal_oid(const ASN1*asn,uint32_t type,FILE*stream)
  Prints a object identifier in decimal format. If any part has a number
  bigger than 160 digits then a question mark is printed instead. (You
  should not use this for comparison; if you want to compare OIDs, then
  you should just compare the binary data directly, instead.)

  Note that this function may print some data and still return an error,
  in case of an invalid encoding. Numbers that are too big is not an error
  but will print a question mark in place of the too big number.

  type = The type can be ASN1_OID or ASN1_RELATIVE_OID. In the latter case,
  it prints two dots before the numbers.

  stream = The file to write to.


=== Encoding functions ===

Most of these functions require a pointer to a ASN1_Encoder object as the
first argument. Use asn1_create_encoder to create this object, and then
use asn1_finish_encoder to destroy it once you are finished with it.

asn1_construct(ASN1_Encoder*enc,uint8_t class,uint32_t type,uint8_t mode)
  Begins a constructed ASN.1 item.

  mode = A combination of flags below (0 to use no flags).

  ASN1_INDEFINITE = Use indefinite length (not valid for DER). This allows
  data to be written to output before the entire contruction is completed,
  so that it can be used with streaming protocols.

  ASN1_ONCE = Automatically ends the construction after a single item
  has been added inside.

ASN1_Encoder*asn1_create_encoder(FILE*file)
  Creates a ASN1_Encoder object that writes its output to the specified
  file (which is not required to be seekable).

FILE*asn1_current_file(ASN1_Encoder*enc)
  Returns a FILE* object for the encoder. This is not necessarily the one
  that has been passed to asn1_create_encoder. You can use this to write
  raw data to the file.

asn1_encode(ASN1_Encoder*enc,const ASN1*value)
  Encodes a single ASN.1 value.

  value = The value to be encoded. This can be any primitive or constructed
  ASN.1 value.

asn1_end(ASN1_Encoder*enc)
  End of a construction started by asn1_construct.

asn1_explicit(ASN1_Encoder*enc,uint8_t class,uint32_t type)
  Like asn1_construct but the mode is always ASN1_ONCE.

asn1_finish_encoder(ASN1_Encoder*enc)
  Finishes an encoder, flushing all data to the output stream, and freeing
  the memory of the encoder. If it returns ASN1_OK or ASN1_ERROR, the
  encoder object is no longer valid after calling this function. If it
  returns ASN1_IMPROPER_MODE then the encoder object is still valid.

asn1_flush(ASN1_Encoder*enc)
  Flush the output file of the encoder. If there is a definite construction
  that is not yet completed, then this will not result in any output.

asn1_implicit(ASN1_Encoder*enc,uint8_t class,uint32_t type)
  Overrides the class and type of the next item to be encoded. Calling it
  after being overridden before writing any more items will result in a
  ASN1_IMPROPER_MODE error.

asn1_primitive(ASN1_Encoder*enc,uint8_t class,uint32_t type,const uint8_t*data,size_t length)
  Encodes a single primitive value.

  class = The class; can be ASN1_UNIVERSAL, ASN1_APPLICATION,
  ASN1_CONTEXT_SPECIFIC, or ASN1_PRIVATE.

  type = The type.

  data = Pointer to the data to be written. This is ignored (and may be
  null) if the length is zero.

  length = The number of bytes of the data.

asn1_wrap(ASN1_Encoder*enc)
  Like asn1_construct(enc,ASN1_UNIVERSAL,ASN1_OCTET_STRING,ASN1_ONCE) but
  the primitive/constructed bit is clear (indicating primitive) instead of
  set. (This is used for the data of X.509 extensions.)


=== ASN.1 data format ===

(TODO)

