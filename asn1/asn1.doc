
=== Structures ===

ASN1
  Represents a single ASN.1 value. See the section below about ASN.1 data
  formats for an explanation of what the ASN.1 formats mean.

  .data = A pointer to the beginning of the raw primitive or constructed
  data, excluding the bytes for the class, type, and length.

  .length = The length of the data in bytes.

  .type = The type number. If the class is ASN1_UNIVERSAL (0) then this is
  one of the constants listed near the top of the asn1.h file.

  .class = The class, which can be ASN1_UNIVERSAL (0), ASN1_APPLICATION
  (1), ASN1_CONTEXT_SPECIFIC (2), or ASN1_PRIVATE (3).

  .constructed = Zero if primitive or one if constructed.

ASN1_DateTime
  Represents a general date/time (using the Gregorian calendar), including
  the time zone.

  .zone = The time zone, in minutes from UTC; positive numbers are east and
  negative numbers are west.

  .year = The AD year number.

  .month = The month number from 1 to 12.

  .day = The day number from 1 to 31.

  .hours = The number of hours from 0 to 23.

  .minutes = The number of minutes past the hour, from 0 to 59.

  .seconds = The number of seconds past the minute, normally from 0 to 59,
  but may be 60 in the case of leap seconds.

ASN1_Encoder
  This is an opaque type, which is used during encoding.


=== Return values ===

Except as otherwise specified, all functions return an error code, where
zero means OK and nonzero means error.


=== General functions ===

asn1_date_to_time(const ASN1_DateTime*in,time_t*out,uint32_t*nano)
  Convert a ASN1_DateTime structure to UNIX time.

  in = The structure with the date/time to be converted.

  out = Where the output time is written to. In the case of leap seconds,
  the timestamp is the same as that for the last second of the same minute.

  nano = It may be null. If it is not null, writes the number of
  nanoseconds past the UNIX time. This is normally less than one billion,
  but can exceed one billion in the case of leap seconds.

asn1_distinguished_parse(const uint8_t*,size_t,ASN1*,size_t*)
  Same as asn1_parse but does not allow indefinite encoding, and requires
  that the type and length are encoded in the minimum number of bytes.

asn1_free(ASN1*obj)
  Frees dynamic memory belonging to the ASN1 structure. (Most functions
  don't allocate dynamic memory in a ASN1 structure, although some do.)

asn1_from_c_string(uint8_t class,uint32_t type,const char*data,ASN1*out)
  Converts a null-terminated C string into a ASN1 structure (which will
  contain a pointer to the string). The type cannot be automatic; it must
  be specified explicitly. Passing a null pointer is an error.

asn1_make_oid(const char*text,ASN1*out)
  Makes a text OID into a ASN1 structure (containing the binary format
  of the OID). This uses dynamic allocation; use asn1_free to free the
  data after you are finished with it.

  text = The text representation of the OID, which is a sequence of
  integers in decimal notation with dots in between.

  out = Pointer to ASN1 structure to write the result to.

asn1_make_static_oid(const char*text,uint8_t*buf,size_t maxlen,ASN1*out)
  Like asn1_make_oid but uses static allocation, so asn1_free is not
  necessary, but you must ensure that the buffer is not changed or
  deallocated until it is no longer in use.

  text = Text text representation of the OID, like asn1_make_oid.

  buf = The buffer to use.

  maxlen = The maximum size of the buffer.

  out = Pointer to ASN1 structure to write the result to.

asn1_parse(const uint8_t*data,size_t length,ASN1*out,size_t*next)
  Parses a ASN.1 BER value from memory. This does not decode the value.

  data = The pointer to the data.

  length = The maximum length of the data. It will not try to read past
  this length. If this length is not big enough to parse a single value,
  then it returns ASN1_TOO_SHORT.

  out = The ASN1 structure to write the parsed value into.

  next = It may be null. If it is not null, then the total length that has
  been read is added to the variable that it points to, so that you may
  know where to start reading from next.

asn1_time_to_date(time_t in,uint32_t nano,ASN1_DateTime*out)
  Converts UNIX time to a ASN1_DateTime structure.

  in = The UNIX time to be converted.

  nano = The number of nanoseconds. If this is one billion or more, then
  it will increase the number of seconds in the output structure; this
  is only valid if the original number of seconds is exactly 59.

  out = Pointer to the structure to store the result.

void asn1_write_length(uint64_t length,FILE*stream)
  Writes a length header of a ASN.1 item. (This function is used
  internally, but is also available for your own use.)

  length = The length of the data within the item (not including the header
  itself). This does not write the data; only the length header is written.

  stream = File to be written to.

void asn1_write_type(uint8_t constructed,uint8_t class,uint32_t type,FILE*stream)
  Writes a class/type header of a ASN.1 item. (This function is used
  internally, but is also available for your own use.)

  constructed = Set to nonzero for constructed or zero for primitive.

  class = Class of value.

  type = Type of value. The class and type should not both be zero.

  stream = File to be written to.


=== Decoding functions ===

Most of these functions have the first two arguments being "asn" and
"type", where "asn" is the value to decode, and "type" specifies the ASN.1
universal type of the value. If the type is ASN1_AUTO then it will decide
the type automatically from the ASN1 structure; in this case, the class
must be ASN1_UNIVERSAL or ASN1_CONTEXT_SPECIFIC (in which case it assumes
it is an explicit type). If the type passed to the function is not
ASN1_AUTO then it assumes that it is an implicit type and uses the type
you specified instead.

asn1_decode_date(const ASN1*asn,uint32_t type,ASN1_DateTime*out)
  Decodes one of the ASN.1 date/time types. The time zone in the output is
  left unchanged if the ASN.1 value does not specify the time zone, but if
  it does specify the time zone then it will use the time zone in the
  ASN.1 value instead. It will also keep any existing values in the output
  structure for the ASN.1 types that only specify date or only time of day,
  in which case the time of day or the date is kept as it is.

asn1_decode_int8(const ASN1*asn,uint32_t type,int8_t*out)
  Decodes a signed 8-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 8-bit integer.

asn1_decode_int16(const ASN1*asn,uint32_t type,int16_t*out)
  Decodes a signed 16-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 16-bit integer.

asn1_decode_int32(const ASN1*asn,uint32_t type,int32_t*out)
  Decodes a signed 32-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 32-bit integer.

asn1_decode_int64(const ASN1*asn,uint32_t type,int64_t*out)
  Decodes a signed 64-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a signed 64-bit integer.

asn1_decode_number(const ASN1*asn,uint32_t type,???*out)
  A macro that calls one of the other numeric decoding functions according
  to the type of the "out" argument.

asn1_decode_time(const ASN1*asn,uint32_t type,int16_t zone,time_t*out,uint32_t*nano)
  Combines asn1_decode_date and asn1_date_to_time. The defaults for any
  fields other than the time zone will be zero.

  zone = The default time zone, in minutes (specify 0 for UTC). It is
  ignored if the ASN.1 value explicitly specifies the time zone.

asn1_decode_uint8(const ASN1*asn,uint32_t type,uint8_t*out)
  Decodes a unsigned 8-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 8-bit integer.

asn1_decode_uint16(const ASN1*asn,uint32_t type,uint16_t*out)
  Decodes a unsigned 16-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 16-bit integer.

asn1_decode_uint32(const ASN1*asn,uint32_t type,uint32_t*out)
  Decodes a unsigned 32-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 32-bit integer.

asn1_decode_uint64(const ASN1*asn,uint32_t type,uint64_t*out)
  Decodes a unsigned 64-bit integer. Returns ASN1_OVERFLOW if the value is
  not in the range of a 64-bit integer.

asn1_get_bit(const ASN1*asn,uint32_t type,uint64_t which,int*out)
  Reads a single bit from a value.

  which = Which bit to read. How this number is interpreted depends on
  the type, as follows:

  ASN1_BIT_STRING: The high bit of the first byte (although this is not
  the first byte of the encoded value) is bit 0.

  ASN1_OCTET_STRING: The low bit of the first byte is bit 0.

  ASN1_INTEGER: The low bit of the last byte is bit 0. If the bit
  position number is out of range, then it uses the high bit of the
  first byte (the sign bit), instead of leaving it unchanged.

  ASN1_BOOLEAN: The bit position number is ignored.

  out = Where to store the bit that has been read. If the requested bit
  number is out of range then it remains unchanged (therefore allowing
  the use of default values, which is usually zero).

asn1_print_decimal_oid(const ASN1*asn,uint32_t type,FILE*stream)
  Prints a object identifier in decimal format. If any part has a number
  bigger than 160 digits then a question mark is printed instead.
  (Important Note: You should not use this for comparison; if you want to
  compare OIDs, then you should just compare the binary data directly,
  instead. Use asn1_make_oid or asn1_make_static_oid if you have a OID in
  text form that you need to compare.)

  Note that this function may print some data and still return an error,
  in case of an invalid encoding. Numbers that are too big is not an error
  but will print a question mark in place of the too big number.

  type = The type can be ASN1_OID or ASN1_RELATIVE_OID. In the latter case,
  it prints two dots before the numbers.

  stream = The file to write to.


=== Encoding functions ===

Most of these functions require a pointer to a ASN1_Encoder object as the
first argument. Use asn1_create_encoder to create this object, and then
use asn1_finish_encoder to destroy it once you are finished with it.

asn1_construct(ASN1_Encoder*enc,uint8_t class,uint32_t type,uint8_t mode)
  Begins a constructed ASN.1 item.

  class = The class.

  type = The type.

  mode = A combination of flags below (0 to use no flags).

  ASN1_INDEFINITE = Use indefinite length (not valid for DER). This allows
  data to be written to output before the entire contruction is completed,
  so that it can be used with streaming protocols.

  ASN1_ONCE = Automatically ends the construction after a single item
  has been added inside.

ASN1_Encoder*asn1_create_encoder(FILE*file)
  Creates a ASN1_Encoder object that writes its output to the specified
  file (which is not required to be seekable).

FILE*asn1_current_file(ASN1_Encoder*enc)
  Returns a FILE* object for the encoder. This is not necessarily the one
  that has been passed to asn1_create_encoder. You can use this to write
  raw data to the file.

asn1_encode(ASN1_Encoder*enc,const ASN1*value)
  Encodes a single ASN.1 value.

  value = The value to be encoded. This can be any primitive or constructed
  ASN.1 value.

asn1_encode_boolean(ASN1_Encoder*enc,int value)
  Encodes a single boolean value.

  value = The value to be encoded; nonzero is true and zero is false.

asn1_encode_c_string(ASN1_Encoder*enc,uint32_t type,const char*text)
  Encodes a null terminated string (excluding the terminator).

  type = The ASN.1 universal type to use. (You can use asn1_implicit if
  you intend a non-universal type.)

  text = The string to be encoded.

asn1_encode_date(ASN1_Encoder*enc,uint32_t type,const ASN1_DateTime*x)
  Encodes a date/time value.

  type = The ASN.1 type to use for encoding. This can be ASN1_UTCTIME,
  ASN1_GENERALIZEDTIME, ASN1_DATE, ASN1_TIME_OF_DAY, or ASN1_DATE_TIME.

  x = The date/time structure.

asn1_encode_int8(ASN1_Encoder*enc,int8_t value)
  Encodes a signed 8-bit integer.

asn1_encode_int16(ASN1_Encoder*enc,int16_t value)
  Encodes a signed 16-bit integer.

asn1_encode_int32(ASN1_Encoder*enc,int32_t value)
  Encodes a signed 32-bit integer.

asn1_encode_int64(ASN1_Encoder*enc,int64_t value)
  Encodes a signed 64-bit integer.

asn1_encode_integer(ASN1_Encoder*enc,??? value)
  Encodes an integer. This is a macro that calls one of the other functions
  for encoding integers according to the type of the specified value.

asn1_encode_oid(ASN1_Encoder*enc,const char*t)
  Encodes a object identifier (OID).

  t = The text representation of the OID (as for asn1_make_static_oid).

asn1_encode_time(ASN1_Encoder*enc,uint32_t type,time_t value,uint32_t nano,int16_t zone)
  Encodes a date/time value from UNIX time.

  type = The ASN.1 type to use; same as for asn1_encode_date.

  value = The UNIX time.

  nano = The number of nanoseconds.

  zone = The time zone, in minutes.

asn1_encode_uint16(ASN1_Encoder*enc,uint16_t value)
  Encodes a unsigned 16-bit integer.

asn1_encode_uint32(ASN1_Encoder*enc,uint32_t value)
  Encodes a unsigned 32-bit integer.

asn1_encode_uint64(ASN1_Encoder*enc,uint64_t value)
  Encodes a unsigned 64-bit integer.

asn1_end(ASN1_Encoder*enc)
  End of a construction started by asn1_construct.

asn1_explicit(ASN1_Encoder*enc,uint8_t class,uint32_t type)
  Like asn1_construct but the mode is always ASN1_ONCE.

asn1_finish_encoder(ASN1_Encoder*enc)
  Finishes an encoder, flushing all data to the output stream, and freeing
  the memory of the encoder. If it returns ASN1_OK or ASN1_ERROR, the
  encoder object is no longer valid after calling this function. If it
  returns ASN1_IMPROPER_MODE then the encoder object is still valid.

asn1_flush(ASN1_Encoder*enc)
  Flush the output file of the encoder. If there is a definite construction
  that is not yet completed, then this will not result in any output.

asn1_implicit(ASN1_Encoder*enc,uint8_t class,uint32_t type)
  Overrides the class and type of the next item to be encoded. Calling it
  after being overridden before writing any more items will result in a
  ASN1_IMPROPER_MODE error.

asn1_primitive(ASN1_Encoder*enc,uint8_t class,uint32_t type,const uint8_t*data,size_t length)
  Encodes a single primitive value.

  class = The class; can be ASN1_UNIVERSAL, ASN1_APPLICATION,
  ASN1_CONTEXT_SPECIFIC, or ASN1_PRIVATE.

  type = The type.

  data = Pointer to the data to be written. This is ignored (and may be
  null) if the length is zero.

  length = The number of bytes of the data.

asn1_wrap(ASN1_Encoder*enc)
  Like asn1_construct(enc,ASN1_UNIVERSAL,ASN1_OCTET_STRING,ASN1_ONCE) but
  the primitive/constructed bit is clear (indicating primitive) instead of
  set (constructed). (This is used for the data of X.509 extensions.)


=== ASN.1 data format ===

(TODO)

