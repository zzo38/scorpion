(DRAFT)
SCORPION PROTOCOL/FILE-FORMAT


=== Protocol ===

The protocol can be TLS or non-TLS. Implementation of TLS is optional but
is recommended; implementation of non-TLS is mandatory if it is possible.
The same port number can be used for TLS and non-TLS; this is distinguished
by the first byte that the client sends (TLS if it is 0x16 or non-TLS
otherwise (in which case it is the subprotocol byte)).

The default port number (for both TLS and non-TLS) is 1517.

Unless otherwise specified, the text in the protocol is ASCII.

The first byte is the subprotocol, and then optional subprotocol parameter,
and then a space, and then the absolute URL (the scheme is mandatory), and
then a carriage return and a line feed. (See the below sections about the
definitions of the send and receive subprotocols. "Subprotocols" is similar
than the different methods of HTTP, such as GET and PUT.)

The server then sends the status line, which consists of a two-digit status
code, followed by a space and then the parameters (which may be empty), and
then another carriage return and line feed. Parameters are separated by
spaces, although the last parameter may include spaces (the client will
know how many parameters according to the major status code).

The URL may include a username/password (the usual format of username and
password in a URL is used); if so, the client should not display the
password (unless the user has enabled an option to tell it to not hide
passwords). The client software should also include a command to discard
any existing username/password, in order to log out.

However, if the URL contains # then the client should not include the #
and what comes afterward, since that part is only for the client.

If the host name of the URL does not match any host name that this server
serves, or if the scheme is neither "scorpion:" nor "scorpions:", then it
is a proxy request (which the server may refuse if it wishes, due to
whatever criteria they want). Proxies should normally avoid converting the
files into a different format. (Note that a proxy to another service on
the same server might be implemented without needing to make another
connection, although this is not mandatory and not something that the
client needs to worry about.)

If it is not a proxy request, then the TLS and non-TLS variants of the
same protocol URI scheme should be treated as equivalent by the server
(but not by the client, which MUST treat them differently). (Proxied
requests will treat the scheme in the request like the client does.)

The recommended use of SNI is:

* Clients SHOULD use SNI when connecting to the server, and MAY have an
option to disable SNI (in order to mitigate some types of spying).

* Servers SHOULD NOT require SNI, and SHOULD ignore any provided SNI and
use the host name in the request instead. (Exceptions are possible, e.g.
if it needs to use a different protocol with the same port number and IP
address for some reason, but this should be avoided if possible.)

* If possible, clients SHOULD allow to use the system's DNS services to
implement encrypted Client Hello; if implemented, there MUST be an option
to disable this feature.


=== Status codes ===

The first digit is the major code, and the second digit is the minor code.
Clients may ignore the minor code.

0x = Interactive mode; used only for the "I" subprotocol. After this is
sent to the client then arbitrary two-way communication is possible. The
parameter is optional and is the capability codes if it is not blank.

1x = Requires input; the parameter is the prompt text, which it should
display to the user, and then the user enters any text, and the client
redirects to the same as the current URL but with ? added and then the text
entered by the user, which should be percent-encoded if necessary. If the
existing URL already has a query string, then the result is unspecified;
servers MUST NOT use this code in that case.

2x = The response is OK and the contents of the file will follow; after
this line is the data of the file. The parameters are:

* The file size in decimal notation, or ? if the size is unknown (e.g. if
it is a dynamic file).

* The file type/format. MIME has some problems and ULFI is better, but for
now, for compatibility you can use MIME; however, spaces are not allowed.
If the "charset" parameter is not included then the default according to
the file format should be used; "us-ascii" is a recommended default.

* Optionally, the version, which if present must consist only of uppercase
and lowercase letters, digits, and forward slash and plus sign. (Clients
and servers are not required to verify that the version code uses this
restricted character set.)

3x = Redirect. The parameter is another URL which it should redirect to,
which can be temporary or permanent.

4x = Temporary error. Has two parameters:

* The number of seconds which is recommended to wait before trying again;
it must be a unsigned 31-bit number (encoded as decimal in ASCII, not as
binary), or it can be ? if it is unable to estimate the required time
before trying again.

* The error message text (optional).

5x = Permanent error. The parameter is an error message. The request should
not be repeated by automatic tasks, unless such tasks are manually reset by
the operator of the computer that controls such tasks.

6x = Client certificate required. The parameters are listed below. The
below section about client certificates has more details.

* The first parameter specifies what URLs the certificate applies to; see
the below section about client certificates. This is only a hint and is not
a requirement; clients MAY ignore it, and MUST allow the user to override
this specification with their own.

* The second parameter is arbitrary text which should be displayed to the
user, to explain what kind of client certificate is needed and/or why it is
needed, etc.

7x = Ready to receive; used only for the "S" subprotocol. The parameter is
an arbitrary text.

8x = Received data accepted; used only for the "S" subprotocol. The
parameters are same as for 2x but the data of the file is omitted. If
the file has been deleted then the parameters are omitted.


=== Detailed status codes ===

00 = Beginning of arbitrary two-way communication. (This is only valid for
the "I" subprotocol.)

10 = Requires input. (This protocol does not have the 11 code that Gemini
has; putting the password in the query string isn't very good because then
it is a part of the URL and might not be hidden.)

20 = Response is OK.

21 = Response is OK, but it is only a part of the file and not the entire
file; this is used as the response of a range request. The file size
parameter is the entire file size, and not only the requested part.

30 = Temporary redirect.

31 = Permanent redirect. A client may automatically update bookmarks, etc
if this feature has not been disabled by the user.

40 = Temporary error with a not more specific code.

41 = Down for maintenance.

42 = A dynamic file has an unexpected temporary error such as time out.

43 = Proxy error; this request requires the server to make another
connection, but it is unable to do so, or is able to connect but cannot
receive a valid response.

44 = Slow down; the client is sending requests too fast and should wait
before trying again.

45 = Temporarily locked file; used with the "S" subprotocol.

50 = Permanent error with a not more specific code.

51 = File not found (maybe it is at Area 51).

52 = The file does not exist (probabily because it has been deliberately
removed) and is not expected to exist again; clients should remember this
and not request it again automatically. (This code also means a permanently
locked file, if used with the "S" subprotocol.)

53 = A proxied request was refused by the server. A server MAY also use
this status code if a username/password have been provided in the URL but
are not required to access any files on this server (this is to simplify
the server implementation, so that it can check that it is not its own name
and therefore refuse the request). A server MAY also use this status code
if a URL with no scheme has been provided, for the same reason.

54 = Forbidden request. A username and/or password probably won't help.
Other conditions might or might not help, depending on the implementation
(e.g. it might only permit access to LAN addresses or only to 127.0.0.1).

55 = Edit conflict; used with the "S" subprotocol.

56 = A username and/or password are required. Either none have been
provided, or the username and/or password that have been provided are
incorrect. The error message SHOULD NOT distinguish between an unknown
username and an incorrect password for a known username.

59 = Bad request.

60 = A client certificate is required to access this file, but none has
been provided.

61 = The supplied client certificate is not authorized to access this file.
The certificate may be valid to access a different file, though (possibly
but not necessarily on the same server).

62 = The supplied client certificate is not valid (e.g. because it has
expired or because the signature is not valid).

70 = Ready to receive new file. (If a server sends this response but the
file is created before it has been fully received from the client for any
reason, then the server SHOULD NOT overwrite the existing file and SHOULD
instead send a response with an appropriate 4x or 5x status code.)

71 = Ready to receive to replace an existing file.

80 = Accepted received data and created a new file.

81 = Accepted received data to modify an existing file.


=== Client certificates ===

Implementation of client certificates is optional, but it is recommended
to be implemented if TLS is implemented.

If a 6x response is received on a non-TLS connection, then it should change
the scheme from "scorpion:" to "scorpions:" when a client certificate is
available, before retrying the request.

The first parameter of a 6x response specifies the suggested set of URLs
that the client certificate is applicable to. It has one character followed
by a URL. The URL may be empty to mean the current URL, or can be any URL
that lacks a scheme and authority. The first character can be:

* "=" = Only that exact URL (as well as any that differ only by the
fragment part; the fragment part is always ignored for all of these modes).

* "+" = The specified URL as well as any that have a different query string
or no query string.

* "*" = Discard the query string of the specified URL, and then it means
the current URL as well as any one consisting of the current URL followed
by / or ? and then anything. If the URL already ends with / then it means
that URL followed by anything.

* "-" = An unspecified set of URLs which includes the specified URL.

(If Gemini is implemented as well as Scorpion, then a 6x response from a
Gemini server SHOULD use the "*" URL set hint (with the current URL) by
default, since that is what the Gemini specification says.)

The set of URLs MUST include the URL that has been requested, and MUST NOT
include any URL that differs by scheme, host, and/or port, than the URL
that has been requested. If this is not the case, clients SHOULD treat it
as an unrecognized hint.

Clients MUST allow the user to override the specifications above; those
specifications are merely a hint, and are not mandatory to be implemented.
Unrecognized hints shouldn't prevent the user from specifying a client
certificate anyways, but in that case the client MAY require that the user
explicitly specify which set of URLs it applies to; if it does not then
there will be a implementation-dependent default setting.

Client certificates normally apply to all subprotocols used with that URL,
although the user may be allowed to override this. Alternatively, a client
might apply it to all subprotocols if the subprotocol in the request is R,
but limit it to the requested subprotocol if it is S or I.

If the server requires a client certificate and a user name, it should use
a 54 response first, and then 60 once a valid username has been provided.
If the server requires either a client certificate or a user name (of the
client's choice), but does not need both, then it should provide a 54
response if the connection is not using TLS, or 60 if it is using TLS. A
server SHOULD NOT require both a password and a client certificate at the
same time.

A client may have any UI its author wishes, but an example of a GUI which
might be used to manage client certificates would be:

  URL: ________________________________
  [X] Restrict to current username
  Subprotocols:  [X] Receive  [X] Send  [X] Interactive
  Duration:  (*) Session  (*) Permanent  (*) ___ hours  (*) ___ days
  [X] Remember TLS options
  <Select...>  <Import...>  <Create...>  <Manage...>
  <Set>  <Set and go>  <Cancel>

(A client can be designed with whatever differences they want than the
above. A similar UI may be used for Gemini, except that "Interactive" and
"Restrict to current username" are not applicable for Gemini.)

In the menu for selecting existing certificates, any existing certificate
for the same domain should be easy to find, and should allow changing the
scope of existing certificates. (This is more important for Gemini than it
is for Scorpion, but it would work with Scorpion too.)

A client MUST NOT automatically generate and send a client certificate
without first asking the user.


=== Receive subprotocol ===

This is the usual subprotocol, coded as "R". (It is the only subprotocol
which is mandatory to be implemented.)

The subprotocol parameter can be blank or can be a range request. Servers
are not required to support range requests, and can respond with a 59 code
if it is not implemented. (It is also possible that range requests will be
possible only with some files and not with other files.)

A range request consists of two nonnegative integers in decimal notation
with - in between; these are zero-based file offsets, of the first byte to
receive, and of the first byte to not receive (e.g. "3-9" means the six
bytes, being the fourth, fifth, ..., ninth bytes of the file). The end
address can be omitted in which case it means up to the end of the file.


=== Send subprotocol ===

This subprotocol is coded as "S".

The subprotocol parameter can be omitted, but if not omitted then it is the
version of the file being replaced; this can check for edit conflicts. (The
server MAY require the version to be specified.)

Optionally, the subprotocol parameter can be a HMAC followed by @ and then
the version (which may be empty). The HMAC is of everything that follows
the at sign, including the entire request and everything the client will
send after the server responds the first time.

The response code should not be 2x nor 8x, but can be any other code. If it
is 7x then this means it is ready for the client to upload the file. If it
is 1x or 3x then they modify the URL and mean that the upload is required to
be made to a different URL instead of the one that was initially requested.

For the client to upload the file, it sends a status lines, and if 2x then
it is followed by the data. The possible status codes are:

* 20 = Upload a file. The size is mandatory and you cannot substitute a
question mark instead. The version is optional, and the server may override
it with its own version specification.

* 30 or 31 = Make the file into a redirect to a different file.

* 51 or 52 = Delete a file.

A server does not need to implement all of the above possibilities.

After the client finishes sending, the server sends the status line, which
will be a 8x code if successful or a different code if it is an error.

Note that if the client disconnects before sending its own status line or
before sending the amount of data of the file that it said it was going to
send to the server, then the upload is aborted; if the file is locked then
the server can unlock it, etc. (For example, a client might not want to
overwrite an existing file, but the server says 71 and the client wants to
add a new file and not overwrite an existing file, then the client can
disconnect, in which case the files on the server will be unchanged.)


=== Interactive subprotocol ===

This subprotocol is coded as "I", and is used for two-way communication
(usually terminal emulation, although it can be used with any kind of
two-way communication). (The main reason for this is if you have
multiple programs and you want to be able to specify the URL of each one.)

The subprotocol parameter is optional but if present it is the requested
capability codes; see below.

If it is acceptable, then the server sends a 00 response; its parameter is
the actual capability codes or can be blank. After that, it will continue
with ordinary two-way TCP communication. (Other valid status codes are 4x,
5x, and 6x, in which case the server closes the connection after that, like
it does with the other subprotocols. The 2x codes MUST NOT be used.)

If the client disconnects after receiving the 00 response (and possibly any
further data) but without sending any further data to the server, then the
server should not change the state; it should assume that the client had
connected by mistake and did not intend to do so.

Capability codes have no delimiters between them, and each one has the
following format (similar than CSI codes, in order that implementations
can use the same subroutines to parse them if they do terminal emulation):

* Zero or one byte in range 0x3C to 0x3F.

* Zero or more bytes in range 0x30 to 0x39 or 0x3B.

* Zero or one byte in range 0x21 to 0x2F.

* One byte in range 0x40 to 0x7E.

(Note that the protocol before the actual data will be ASCII only, so that
ait is possible to use even with terminal emulators that do not implement
this subprotocol.)

Possible capability codes:

* L = Line mode. The value is 0 for not local line editing (and not local
echo), or 1 for local line editing so that the text is not sent until an
entire line is entered and the user pushes send. Even in line mode it is
still possible for the server to send data to the client while the user
has partially entered a line of text; the client should handle that by
displaying the user's text entry separately.

* x = Screen size. The value is two numbers being the number of columns
and the number of rows; in both cases zero can mean unlimited. Optionally
can have a third number; 1 means the client handles pagination.

(Note that it is not required to implement the above capability codes. In
some cases, some or all of them might be not applicable, e.g. if it is not
a terminal emulation.)


=== Hashed URI scheme ===

The "hashed:" URI scheme has the format "hashed:X/Y,Z" where X is the
hash algorithm, Y is the hash (in hexadecimal format), and Z is another
URL (which can be absolute or relative, and can be of any scheme, including
another "hashed:" URL, in case you want to specify multiple hashes which
are using different hashing algorithms).

It refers to the same file as Z if X/Y is that file's hash, or is an error
if that file's hash is not X/Y.

If "[X|Y]" means the absolute URL corresponding to the URL Y treated as
relative to the absolute URL X, then the rules for resolving relative URLs
of this scheme are as follows:

"[hashed:A/B,C|D]" = "[C|D]" if "D" does not start with "#"

"[hashed:A/B,C|#D]" = "hashed:A/B,[C|#D]"

"[A|hashed:B/C,D]" = "hashed:B/C,[A|D]"

In case the notation is confusing: "[http://example.org/files/1.txt|2.txt]"
= "http://example.org/files/2.txt" is a valid equation, and the uppercase
letters in the above are placeholders.

For example, if the current URL is "hashed:0/ab8974,file:///tmp/help.txt"
and you want to access the relative URL "help2.txt", then the new absolute
URL is "file:///tmp/help2.txt" and not
"hashed:0/ab8974,file:///tmp/help2.txt", because "0/ab8964" is the hash of
"help.txt" and not of "help2.txt". However, if the relative URL starts with
# then it is a link to another part of the same file, so it is the same
file and therefore has the same hash and therefore it should not strip out
the hash in this case.

The hash algorithms are specified as hexadecimal numbers without a leading
zero, which are multicodec numbers (but not encoded as varint). The hash
values are specified as an even number of hexadecimal digits, which will
include leading zeros if any. List of hash algorithms:
  11  SHA-1
  12  SHA2-256
  13  SHA2-512
  14  SHA3-512
  15  SHA3-384
  16  SHA3-256
  17  SHA3-224
  d5  MD5

(Note that some hash algorithms are deprecated because they are insecure.)

(A request of the Scorpion protocol that sends a URL using the hashed:
scheme is considered to be a proxied request (even if it is a URL of a file
on that server), and may be refused.)


=== Document file format ===

The file format consists of a sequence of blocks, each of which has the
format (there is no global header, delimiters, etc):

* One byte being the block type and character encoding.

* Big-endian 16-bit attribute length.

* Attribute data.

* Big-endian 24-bit body length.

* Body data.

The block types are:

* 0x00 = Normal paragraph. The attribute is unused and MUST be empty. The
body is the text of the paragraph.

* 0x01 to 0x06 = Heading levels 1 (outermost) to 6 (innermost). The
attribute is the part after # in the URL to refer to this section (empty
if it cannot be referred to by the URL), and the body is the heading text.

* 0x08 = Normal hyperlink. The attribute is the URL (in ASCII encoding)
and the body is the link text. The URL can be relative or absolute. If the
attribute is empty then it means the same as the current URL (which isn't
very useful for type 0x08, but may be useful with types 0x09 and 0x0A). If
the attribute contains a null character, then only the part before the null
character is the URL, and the null character itself and anything afterward
will be ignored. Other control characters are not allowed in the URL.

* 0x09 = Hyperlink requesting input. Like 0x08 but it is treated like a
10 status code (with an implementation-defined prompt; it may be the same
as the text of the link) without making the request. This link type is not
to be used for gopher links (if it occurs anyways, a client SHOULD treat
it as a normal hyperlink but with type 7 instead of 1; however, authors
should be aware that a client might incorrectly use a question mark instead
of a tab if this block is used for gopher links).

* 0x0A = Interactive hyperlink. Like 0x08 but with the "I" subprotocol.
Implementation is optional. (Some implementations may wish to use an
external program which is an existing terminal emulator, if they can
add initial input.)

* 0x0B = Alternate service (e.g. mirrors, etc) than the previous block
(which MUST be a link block; if it is also 0x0B then it is an additional
alternate service), or, if there is no previous block, the current file.
The attribute is the URL of the alternate service. The body is not normally
used, but may contain text explaining the alternate service. Clients SHOULD
normally hide this block, although it might have a way to display some kind
of "alternate service" menu, to have an option to display them, to have an
option to automatically select for load balancing, etc. (This is similar
than the "+" type in Gopher menus.)

* 0x0C = Blockquote. The attribute is unused and MUST be empty. The body
is the text of the paragraph.

* 0x0D = Preformatted text. Valid control codes are tab and line feed. The
attribute SHOULD be blank; see below for its meaning (although a client is
allowed to ignore the attribute). The client MUST display this text with a
fixpitch font.

The possible character encodings are:

* 0x00 = TRON-8 (left to right)

* 0x10 = PC (left to right)

* 0x80 = TRON-8 (right to left)

The control codes are:

* 0x09 = Tab; only in a preformatted block. This should not be used if
exact spacing is requred, since the way that it is displayed is
implementation-dependent (and possibly configurable by the user).

* 0x0A = Line break; only in a preformatted block.

* 0x10 = Only with PC character code; follow by one byte in range 0x41
to 0x5F, and you must subtract 0x40 to make the code of the graphic
character to display. This is allowed in preformatted blocks as well
as in other blocks.

* 0x11 = Normal style.

* 0x12 = Strong style.

* 0x13 = Emphasis style.

* 0x14 = Fixpitch style. This style MUST be displayed by fixpitch fonts
(but it is acceptable to display everything by fixpitch fonts, which
would mean that a special handling is not required).

* 0x15 = Forward text direction.

* 0x16 = Reverse text direction.

* 0x17 = Begin the main text of furigana. This should be followed by
the text and then 0x18 and then the other text and then the 0x19.

* 0x18 = Begin the furigana text of the furigana. If furigana is not
implemented (or if the user disabled it), then it should display the
main text of a furigana block but should not display the furigana text.

* 0x19 = End of the furigana. You are not supposed to nest any other
control codes inside of the furigana blocks.

* 0x1B = Used for SGR codes. The next byte MUST be 0x5B, and then zero
or more bytes in range 0x30 to 0x3B except 0x3A, and then one byte
which is 0x6D. This is allowed in both preformatted blocks and in other
blocks, but it is discouraged, especially in non-preformatted blocks.
Clients should skip over the SGR code entirely, but MAY have an option
to interpret them (possibly only in preformatted blocks).

It is not required to implement most of the control codes, except as
specified above.

Stateful encodings MUST shift the state at the beginning of each block.
It is also required after 0x18 or 0x19 if the state before such a code
does not match the state at before the furigana block. Any document
which does not satisfy this criteria may result in an unreliable display
on some clients.

If the attribute of a preformatted block is not empty, then a client
program MAY be able to use it to implement syntax highlighting, equations,
simple diagrams, etc. It MUST have an option to ignore the attribute if the
user wants to display all preformatted block as plain text, and MUST treat
unrecognized attributes the same as a blank attribute. Authors should write
the document with the expectation of the client not recognizing it. Clients
MAY display the attribute text of preformatted blocks.

(If data tables are required, you can link to a separate file that
contains the data; you cannot have inline data tables.)


=== Database file format ===

This file format is optional to implement. (However, scientific clients
should implement this format. Another possibility is to use separate
software to handle this; it might or might not be displayed in the same
window even if separate software is used.)

Each item consists of:

* One byte being the flag byte.

* The length of the data. This is a big-endian number. How many bytes are
needed for the length depends on the low 2-bits of the flag byte: zero (no
data) if 0, one byte if 1, two bytes if 2, or four bytes if 3.

* The data.

The bit3 and bit2 of the flag byte specify the command, which can be:

* 0 = A data cell. There must be begin table or matrix before this command.

* 1 = Begin a new table (high nybble 1) or matrix (high nybble 2) or
relational (high nybble 3), or end of file (high nybble 0).

* 2 = A data cell with null data. The entire flag byte should be only 0x02.

* 3 = (Reserved)

The meaning of the high nybble of the flag byte depends on both the command
and on the schema. In the case of data cells, this is called the "subtype".
In some cases, it specifies the character encoding, which uses the same
numbers for character encodings as the document format uses.

A table specification consists of:

* The table name (in ASCII encoding), prefixed by a one byte length.

* One byte indicating how many fields.

* The specifications for each field; see below.

A matrix specification is similar, but there is only one field, and instead
of one byte indicating how many fields, you will have two big-endian 24-bit
numbers being how many rows and how many columns.

A field specification consists of:

* The field name (in ASCII encoding), prefixed by a one byte length.

* The type/flag byte. The type is low nybble and the flag is high nybble.

The data types are listed below.

* 0x00 = Blob. The subtype has no inherent meaning but you can use it for
your own use.

* 0x01 = Plain text. The subtype is the character encoding.

* 0x02 = Scorpion paragraph text. The subtype is the character encoding.

* 0x03 = Scorpion preformatted text. The subtype is the character encoding.

* 0x04 = URL (in ASCII encoding). The subtype is 0.

* 0x05 = Integer, encoded as big-endian. The subtype is 0x00 for a
non-negative integer or 0x80 for a negative integer (it will use the
bitwise complement of the encoded number). The size can be any number,
including zero, to make arbitrarily big integers (although some
implementations might be limited).

* 0x06 = Floating point, encoded as big-endian IEEE 32-bits or 64-bits.
The subtype is 0.

* 0x07 = Date/time. The subtype specifies which subfields are present,
where 0x10 means the 16-bit signed time zone offset (in minutes), 0x20
means the 32-bit signed number of nanoseconds, and 0x80 means that the
timestamp is negative (as for the integer data type). It is then followed
by the integer number of seconds excluding leap seconds since January 1,
1985, 00:00:00, UTC (it can be any length, as the integer data type).

The flags of fields can be:

* 0x80 = If this field is a part of the primary key. (The primary key is
not mandatory.)

* 0x40 = Allows the data to be null.

Relations are specified as:

* Two table names (in ASCII encoding), each prefixed by a one byte length;
the first is the table containing the field that references a record in
the second table.

* Any number of one byte zero-based field numbers in the first table, which
must be the same number of how many fields make up the primary key in the
second table.


=== Automated crawling ===

(This section is currently a draft and may be changed in future. There is
some disputes about some of the below, so it is likely to be changed.)

Please note that all of this section is not actually enforceable and is
not intended to be. It is intended to be guidelines for bots that is
likely to be implemented correctly when it is implemented. It is a similar
idea than the "robots.txt", but is meant to be less ambiguous.

The recommendation for automated crawling/indexing is described here. This
specification applies to recursive crawlers that automatically download
files, especially if they use recurring intervals, and to public search
engines and mirrors that work automatically. It does not apply to users
that manually download files or that only download a single list of files
once, nor does it apply to proxies, gateway services, etc (but see below
about proxies that are themself available to be crawled).

Note that this does not probhit anyone from making links to any files
regardless of whether or not crawling is allowed.

It should first try to download the file named "/.special/crawl" to find
the policy set up by the server administrator (it should not do this more
than once per crawling interval). Depending on the status code returned by
the server:

* 2x = Read and parse the file according to the below specifications.

* 4x = Do not access the server for at least the specified amount of time,
possibly plus some random number. After that, the crawler MAY try again,
and will again try to download the /.special/crawl file.

* 5x = No crawling policy is available. (The behaviour of a crawler in such
a case is not specified by this document.)

Note that you cannot assume that the crawling policy file will not be
changed in future. If you start over the crawling then you should try to
download the crawling policy file again.

The format of the file is lines ending with line feeds; each line starts
with one byte command code, and then the parameter. If the command code
has bit5 set then it SHOULD skip that line if it is not understood. If it
has bit5 clear then the client MUST treat the entire file as not understood
and should not proceed with crawling (and it might abort with an error
message in this case, explaining what the problem is).

Each crawler also has zero or more names, which are sequences of printable
ASCII characters.

The commands are:

* "`" = A comment that has no meaning. It may contain information which is
useful for users, search engine operators, mirror operators, etc, such as
downloading an archive file that contains all of the data.

* "@" = The parameter is the name of the crawler. Any lines preceding the
first line with @ are effective, and anything from the first @ line
matching the crawler's name up to the next line with @ are effective; all
other lines are ineffective. Ineffective lines MUST be ignored even if the
bit5 of the command code is clear.

* "i" = Suggests indexing the specified prefix.

* "v" = Suggests not indexing the specified prefix.

* "d" = Means that the files with the specified prefix are probably dynamic
so it might not be useful to mirror them.

* "c" = Allows crawling the specified prefix.

* "C" = Disallows crawling the specified prefix.

* "n" = Estimated number of files to download.

* "t" = Estimated total size of files to download.

* "N" = Maximum number of files to download.

* "P" = Maximum number of simultaneous downloads.

* "D" = Minimum delay (in seconds) after downloading one file before
proceeding with the next one.

* "R" = Minimum delay (in seconds) after starting to download the first
file before starting over from the beginning.

* "w" = Suggested time (in seconds) to wait before downloading the crawling
policy file again. Note that the crawling policy file still counts as a
file for the purpose of the D and R commands, too.

* "a" = (This command is intended to be used for archiving, but the
specification of the archiving has not been written yet.)

Numbers are given in decimal notation, and are always nonnegative integers,
using only digits 0 to 9. URL prefixes start with / and are relative to the
root directory of the server; it matches all URLs that it is a prefix of
(including that URL itself).

Once a command is found that matches the URL being accessed, then it should
ignore all further commands for the purpose of accessing that URL. However,
it still must keep those commands in memory or on disk so that it can refer
to them again later for another access. (It is also possible to work in an
alternative way, by somehow converting the data into an internal format on
the client that can more efficiently determine the access policy, as long
as the behaviour matches that described here.) If no command is found that
matches the URL that it wants to access, then assume that an implicit "C/"
follows (meaning it is disallowed).

A crawler may have a name with <> around it (in addition to its other
names) if it has the purposes described below:

* "<MIRROR>" = Mirrors and backups.

* "<SEARCH>" = Public search engines and indexing. This also applies to
proxies which do not themself have a policy to prohibit indexing.

* "<STUDY>" = Programs that are intended to study statistical properties
such as number of files, average file sizes, broken links, etc.

All crawlers MUST have an empty string as one of their names.

If a proxy service is available to be crawled/indexed, then the proxy
service should also check the above policies, and either refuse the proxy,
or to set up its own policy which prohibits access to the proxied files
to automated crawlers (either conditionally (according to which Scorpion
server is being accessed) or unconditionally (for all proxied files,
regardless of which server it is accessing through the proxy)).

Clients MAY add a query string when requesting the crawling policy file
which identifies the crawler. (This is only for the crawling policy file;
it is not supposed to do that for any other file. Also, the identification
does not necessarily match the crawler's name as described above.)

Crawlers that receive a 41 response when downloading any file other than
the crawling policy file SHOULD try to download the crawling policy file
again after waiting for the minimum time specified in the response
(whether or not it has previously downloaded the crawling policy file
successfully in the past).

The crawling policy file is not allowed to be retroactive.


=== Conversion ===

This part of the specification is optional.

Conversion between file formats is possible, and can be specified by the
file called "/.special/conversion". Clients MUST NOT try to download this
file unless the user explicitly commands the computer to do so; it is not
supposed to do so merely by finding a file that is not known how to handle.
(Client software also MUST allow the user to override them and remove any
such files that have already been downloaded.)

Furthermore, any client that is able to understand it MUST NOT require that
it comes from the same server as the file; it can also be a local file
which has been written by the end user, a file from another server (or the
same server but a different path) etc, and once a conversion has been
enabled by the user then the same conversion might be used with other
servers too if apporopriate (not all kinds of conversions are appropriate
for using with other servers (e.g. if file name rewriting is used then it
is not appropriate for arbitrary servers), but some can).

Clients might also have their own mechanisms for conversion beyond what are
written here, e.g. allowing to use local programs with pipes (which is a
recommended way of doing so); such ways can only be used if set up by the
end user or the system administrator and cannot be specified by servers.
(This is possible even if the rest of the specification in this section of
this document is not implemented.)

Each record consists of the 8-bit record type, and then four fields which
are each the big-endian 16-bit length and then the data.

If the high bit of the record type is clear then the first field specifies
the input format and the second field specifies the output format. If the
high bit of the record type is set (currently there are no defined record
types which use this) then the first field specifies the original URI
scheme and the second field specifies the target URI scheme. For some
record types, it is allowed for one or both fields to be empty.

The record types are:

* 0x01 = File name rewriting. The third field is a file name suffix
(excluding any ? or # and anything that comes afterward) of the original
file (if the file name does not match, then this record does not match
and cannot be used with this file), and the fourth field is the suffix to
replace the original suffix with to find the alternative file.

* 0x02 = Use a program to convert the file. The third field is the URL of
the program. The fourth field is described below.

* 0x03 = Use interactive mode. The second field should be blank. The third
field is the recommended capability.

* 0x04 = Use a program to display the file. The third field is the URL of
the program. The fourth field is described below. The second field should
be blank.

For record type 0x02, the fourth field has the first byte specifying the
program format and the rest as the parameters:

* 0x01 = It is a binary uxn / varvara program. The file name and file stat
ports should not be used, and neither should the date/time ports be used,
nor any device ports that are not valid for non-GUI mode. If there are
errors during the conversion, they should be written to stderr and end
with a nonzero exit code.

For record type 0x04, the fourth field has the first byte specifying the
program format and the rest as the parameters:

* 0x01 = It is a binary uxn / varvara program. It will run in GUI mode but
is likely to be sandboxed (which clients SHOULD do if possible).

For record type 0x02 and 0x04 and program format 0x01, the parameter is one
byte, and is a bit field as follows:

* bit0 = Clear for stdin/stdout, or set if the first file device is the
input file (which is read only) and the second file device is the output
file (which is normally write only, but other flags may affect this).

* bit1 = Set if the input file is seekable and can be closed and reopened
(which requires some of the nonstandard features of uxn38).

* bit2 = Set if the output file is seekable and can be closed and reopened,
and might also be read by the program as well as written. (These also
require some of the nonstandard features of uxn38.) (This bit should not
be set if the record type is 0x04, since there is no output file.)

* bit3 = Set if the first command-line argument is the picture size, in the
decimal ASCII format (only digits 0 to 9) with "x" in between (where the
horizontal size is first, and then the vertical size). (This is meant for
scalable vector diagrams.)

Note that it is OK if there are multiple records which match the same file.

Recommended output formats for pictures are farbfeld (true colours) and
XPM2 (indexed colours, which also allows specifying symbolic colours which
can be specified by user preferences). In the XPM2 format, you should not
use X11 colour names; only hex, "black", "white", "None", and symbolic
names (with the "s" colour type) should be used.


=== Recommendations and other notes ===

There are only two legitimate uses for the version field of the 2x
response; a client MUST NOT use it for any other purpose. They are:

* To use as the subprotocol parameter of a upload, to avoid edit conflicts.

* When making a range request, to compare the entire status text to check
if the file might have changed. This is only to be used for resuming a
download and is not to be used for caching.

Clients MUST implement the non-TLS protocol and SHOULD implement the TLS
protocol. Servers SHOULD implement both protocols, especially the non-TLS
protocol. Servers SHOULD serve the same files regardless of whether it is
TLS or non-TLS (except files which require a client certificate to access).

The recommended way to handle TLS cipher suites, TLS validation, etc, is
whatever way the client software uses for any protocols that it already
implements (e.g. Gemini client can use TOFU, curl can validate them in the
usual way but allow bypassing by the -k switch). However, a client should
include the possibility for the user to change the options, and for the
user to manually add and remove certificates. It should also be possible
for the user to specify the security levels when manually adding
certificates (in order to prevent downgrading attacks).

Unicode is no good. Clients SHOULD NOT automatically convert TRON code
into Unicode, except as a fallback in case suitable fonts are not available
or a similar problem, and such fallbacks should be avoided if possible.

Redirects should not be overused.

A client should have a redirect limit; the default redirect limit should
not exceed five. If a redirect would occur beyond the limit (which may be
configurable by the user), or if a TLS connection redirects to a non-TLS,
or to specific other protocols (e.g. HTTPS), or a connection to the
internet tries to redirect or link to a LAN or localhost address (it
should resolve the DNS first if necessary) or to a local file (the "file:"
scheme), then it should warn the user first (with a non-modal message if
possible), and not redirect unless the user manually allows it.

Clients made for users to view (i.e. not something like curl which is only
for downloading files and not for display) should implement at least the
above file format specification (or a subset of it which is at least the
minimal subset) and the "text/plain" format. It is also recommended
(although a lesser recommendation) to implement the "text/gemini" format,
especially if the client software also implements the Gemini protocol.

Clients should allow URLs entered by the user to be treated as relative
if no scheme has been explicitly specified by the user.

It is recommended to have an option to display a table of contents window
for any file formats that it is suitable.

IDN is not required to be implemented (and is recommended to not do so
unless it is already implemented for other reasons). If it is implemented,
clients should use a different colour to display non-ASCII characters for
security purpose, and should ensure that even invisible characters are
displayed. It must include an option to use only ASCII, and it is
recommended to use only ASCII for domain names.

Clients should not download any additional files or make any additional
network requests due to the contents of a document that are merely being
viewed; it should do so only by the user selecting links in the document.
("Selecting" a link means explicitly navigated to or redirected to, not
merely hovering or things like that.)

It is acceptable for a minimal client to only implement the "R" subprotocol
and not implement range requests; the same is true for a minimal server.

If the jar: scheme is implemented, then file: URLs which reference a ZIP
archive should automatically redirect to the jar: URL for the root
directory of the ZIP archive. If it is a Gempub file, it may redirect to
the index file instead (possibly subject to user configuration); even if
it does, it should be possible for the user to manually enter the jar: URL
for a directory listing instead.

It is possible (but probably unnecessary, since SOCKS can be used instead,
which would be better) for a server to implement a proxy with raw data, by
using the "I" subprotocol and the "tcp://" URI scheme in the request. (It
is recommended to use SOCKS instead if possible.)

Don't use R subprotocol to change the state of files in the server, except
for optional logging (which should only be used for diagnostics). For
example, don't use it for adding user's comments, etc. (If you want to have
discussion forum with commenting, then NNTP is better. You can link to a
NNTP from a Scorpion file if you want to do. The S subprotocol may also be
used, and so can the I subprotocol; in the case of the I subprotocol, it
should not change the state of files in the server unless the server
receives any data from the client after the server sends the 00 status.)

Clients SHOULD allow the user to specify proxies. It is recommended to
support SOCKS (unless the operating system has the ability to do so without
the application programs being aware of it). It is also recommended (if
use of proxies are implemented) to allow use of a Scorpion server for
proxying with schemes specified by the user; note that if the proxy URL
does not specify a secure connection, then it should not encrypt any data
sent through the proxy even if the scheme for the file being accessed is
"scorpions:" or "gemini:" or another protocol that uses TLS. This is useful
if the end user has set up their own intercepting proxy on their own
computer, since it allows 


=== Dynamic files ===

Servers can implement dynamic files however they want to do (including not
at all), but the suggested convention on POSIX systems is as follows:

Set argv[1] to the entire request (excluding CRLF). Set argv[2] to the
part of the request following the name of the external program (also
excluding CRLF); note that there might be a path and/or a query string
in argv[2], or it might be empty, but don't omit it even if it is empty.

It is up to the external program to parse the subprotocol parameters, and
to check if the subprotocol is one that it can handle.

Environment variables can be used for the remote IP address (if any program
requires it) and for client certificates (if any have been provided):

* REMOTE_HOST = The IP address of the client.

* SSL_CLIENT_DN = Distinguished name of verified client certificates.

* SSL_CLIENT_I_DN = Issuer DN of client certificates.

(TODO: Keys of client certificates.)


=== Security issues ===

This section discusses security issues. Note that many security issues
with WWW are not applicable to Scorpion and related protocols, since
they do not have the complexity of WWW.

(TODO)


=== Missing details ===

This section describes what is currently missing or incomplete in this
document. They are:

* Some of the above sections has parts which are incomplete.

* If any part of the document is unclear, improve it.

* Comparison with other protocols and file formats.

* Better examples.

* A reference implementation. (This is partially written.)

* TLS is rather complicated, and has some other problems. Is there a
better simpler way to do secure internet?

(It is also possible that other changes may be made in future, than
the above, including changes to existing things, and possibly also
removing things if they are unnecessary.)


=== FAQ ===

*** What are the design goals?

* Simplicity is important, but should include a good set of features.
Features should be made optional as much as possible (and authors should
use only the really necessary parts), and can be implemented independently
as needed. However, it is also necessary to consider if simplifying some
things too much would result in additional complexity elsewhere (a
criticism of Gemini protocol once mentioned).

* Low-level programming is considered and not only high-level.

* Multiple implementations should be possible, and they might have some
of the same and some different features. It should also be possible that
implementations of some protocols/formats can be used together with other
implementatations of other protocols/formats, e.g. if there is a link to
a picture you can use an external program to display or convert it.

* Whether or not HTTP, HTML, and other protocols does or does not do
something (or whether or not it can emulate them) is not a reason to
do or not do something in this protocol and file format. This is not
meant to be a subset or a superset of the capabilities of any other
protocol or file format.

* It should be designed for user autonomy, and for things to be set by
the user instead of by the document author, where possible. (For example,
there is no CSS.) (This is similar than Gemini's principles.)

* Criticisms of this and other formats (such as Gemini) should be
considered, although they might be rejected.

* Other protocols and file formats are not obsolete, just as Gemini does
not intend to replace gopher and web, either. (It is especially not
intended to replace NNTP and IRC; those protocols should still be used
for public communication of many writers, since those are better ways of
doing it than using web forums, mailing lists, proprietary apps, etc.)

* The file format should be suitable both for on screen and printing out.
(As in Gemini, there are no inline links, although Gemini has a different
reason to avoid inline links.)

* Avoid wasting the computer's power when it is not needed.

*** What is the reason for the name?

The Gemini is the name of a constellation (even though that is not why
Gemini protocol was named as such), so I use a different one, such as
the Scorpion.

*** What is the reason for the default port number?

It was chosen by asking someone else, who suggested 1517 because it is a
date of historical significance (the Protestant Reformation), as well as
being a number between 1024 and 32767. According to who suggested it, "the
current state of the internet is in dire need of reformation especially how
dire a perverted mess the web has has become", and the author of this
document agrees with that too.

*** What is the TRON character code?

For some details, see:
  http://tronweb.super-nova.co.jp/chinesecharsandtroncode.html
  http://tronweb.super-nova.co.jp/unicoderevisited.html
  http://zzo38computer.org/fossil/osdesign.ui/finfo?name=draft/charsets
  http://fileformats.archiveteam.org/wiki/TRON_code

Note that the Unicode planes are deprecated in the Extended TRON Code.

*** Why is it restricted to ASCII only?

There are a few reasons for this:

* It improves the simplicity in some cases.

* The URL and some other parts are "computer code", where large character
sets are inappropriate due to homoglyphs and other complexity; it isn't
meant to be text in any language.

* Plain text files are ASCII at the simplest case, but you can still
specify a different character encoding anyways.

Note that not everything is restricted to ASCII only; specifically, the
documents are not restricted to ASCII only.

*** How is it comparing with HTTP(S)/HTML?

It is a different protocol and file format, but by analogy with HTTP and
HTML are specified below:

1. The only response headers are Content-Type (although it can use ULFI and
not only MIME), Content-Length (optional), and ETag (also optional, and it
cannot be used for tracking; see below). For redirection, the equivalent of
the Location header is used.

2. The methods are GET ("R" in Scorpion) and PUT ("S" in Scorpion); there
is no POST request.

3. The only request header used for all requests is Host. GET requests also
can have Range, while PUT requests have Content-Length (mandatory for PUT
requests) and If-Match (optional for PUT requests). (Note that If-Match
cannot be used for GET requests.)

4. The file format uses <P>, <PRE>, <BLOCKQUOTE>, <ISINDEX>, <H1> to <H6>,
and <A>, but with more limits than HTML has (e.g. links must be on a line
by themself). There are also some inline formats which are mutually
exclusive, which are the equivalent of <STRONG>, <EM>, and <TT>.

5. It uses TRON character code instead of Unicode.

6. Character sets can be mixed in one file.

7. There is no cookies, tracking, scripts, CSS, etc. (This is deliberate.)

8. Like with Gemini, and unlike HTML, Scorpion does not require multiple
accesses to display a single document.

*** How is it comparing with Gemini?

1. TLS is not mandatory.

2. There is limited specification of formatting within paragraphs (only
four mutually exclusive kinds: normal, strong, emphasis, fixpitch).

3. There is support for furigana (clients may ignore it).

4. All 4x responses specify the estimated time you should wait before
trying again, instead of only one of them.

5. The 2x responses specify the file size (if known).

6. Range requests are possible (servers and clients are not required to
implement them).

7. It uses TRON character code instead of Unicode.

8. Character sets can be mixed in one file.

9. The specification is intended to be less ambiguous than Gemini.

10. URLs are ASCII and not UTF-8.

11. TOFU is not the recommended way to be implemented. (Better is, if the
user already knows the required certificate, they can install it manually.)

12. PUT requests are possible. (Titan allows this with Gemini, but I think
there are some problems with Titan.)

13. Username/password auth is possible.

*** How is it compating with Gopher?

1. Character encodings can be specified.

2. You can mix document and links together, and there are some formatting
codes available (e.g. blockquote, strong, fixpitch, headings).

3. MIME and ULFI can be used, instead of the limited types of Gopher.

4. Relative URLs are possible.

5. Domain-based virtual hosting.

6. Error codes.

7. The file size is transmitted (if known) instead of using "." on a line
by itself. Range requests are also possible (if implemented; the
implementation of range requests is optional).

8. Optional TLS is possible.

*** Why is there no support for styling?

This is deliberate; the style should be controlled by the user, and not by
the author. Documents can only specify a limited set of styles, and the
user may be able to configure how exactly each one is displayed (by fonts,
colours, etc).

Furthermore, different clients for different displays might prefer a
different style too, instead of the author having to try to make one that
will work for everyone and then it doesn't work for everyone.

*** What should be done if required parameters of status line are missing?

This is technically an error. However, implementations that wish to recover
from such errors may treat "2x" as "2x ? :" and "4x" as "4x ?", where the
colon by itself is the ULFI that does not specify any file formats. For
redirects (3x status codes), any default value would be inappropriate, so
it cannot try to recover from such errors in this way and instead will
have to display an error message.

*** What is the copyright of this file?

This document is public domain.

